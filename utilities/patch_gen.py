#!/usr/bin/env python3
"""
Smalipatch file generator. Create .smalipatch files from modified smali files.



Usage:
    smalipatch-generator.py <original_file> [output_patch]

Arguments:
    original_file    Original smali file to monitor
    output_patch     Output .smalipatch file (default: changes.smalipatch)



Examples:
    # Basic usage
    smalipatch-generator.py MainActivity.smali

    # Specify output file
    smalipatch-generator.py MainActivity.smali my-patch.smalipatch

    # Generate patch for entire directory comparison
    smalipatch-generator.py --dir original/ modified/ output.smalipatch
"""

import os
import sys
import re
import argparse
import difflib
from typing import List, Tuple, Optional, Dict
from pathlib import Path
from datetime import datetime

__version__ = "0.1 alpha"


class SmaliElement:
    """Represents a smali code element (method, field, etc.)"""
    
    def __init__(self, element_type: str, signature: str, start_line: int, end_line: int, content: List[str]):
        self.type = element_type  # 'method', 'field', 'other'
        self.signature = signature
        self.start_line = start_line
        self.end_line = end_line
        self.content = content


def parse_smali_structure(lines: List[str]) -> Dict[str, SmaliElement]:
    """Parse smali file into structured elements."""
    elements = {}
    i = 0
    
    while i < len(lines):
        line = lines[i].strip()
        
        # Parse methods
        if line.startswith('.method '):
            method_sig = line
            start = i
            i += 1
            
            # Find end of method
            while i < len(lines) and not lines[i].strip().startswith('.end method'):
                i += 1
            
            if i < len(lines):
                end = i
                content = lines[start:end+1]
                elements[method_sig] = SmaliElement('method', method_sig, start, end, content)
                i += 1
            continue
        
        # Parse fields
        elif line.startswith('.field '):
            field_sig = line
            elements[field_sig] = SmaliElement('field', field_sig, i, i, [line])
            i += 1
            continue
        
        i += 1
    
    return elements


def generate_method_patch(old_lines: List[str], new_lines: List[str], method_sig: str, context: int = 3) -> Optional[List[str]]:
    """Generate PATCH hunk for method changes."""
    # Remove method declaration and .end method
    old_body = old_lines[1:-1] if len(old_lines) > 2 else []
    new_body = new_lines[1:-1] if len(new_lines) > 2 else []
    
    # Generate unified diff
    diff = list(difflib.unified_diff(old_body, new_body, lineterm=''))
    
    if not diff or len(diff) < 3:
        return None
    
    # Convert to patch operations
    operations = []
    for line in diff:
        if line.startswith('---') or line.startswith('+++') or line.startswith('@@'):
            continue
        elif line.startswith('+'):
            operations.append(f"+ {line[1:]}")
        elif line.startswith('-'):
            operations.append(f"- {line[1:]}")
        else:
            operations.append(f"  {line[1:]}" if line.startswith(' ') else f"  {line}")
    
    if not operations:
        return None
    
    # Add context
    result = [f"PATCH {method_sig}"]
    result.extend(operations)
    
    return result


def generate_patch_from_files(original_path: str, modified_path: str) -> List[str]:
    """Generate patch lines from two file versions."""
    # Read files
    with open(original_path, 'r', encoding='utf-8') as f:
        original_lines = [line.rstrip('\r\n') for line in f.readlines()]
    
    with open(modified_path, 'r', encoding='utf-8') as f:
        modified_lines = [line.rstrip('\r\n') for line in f.readlines()]
    
    # Parse structures
    original_elements = parse_smali_structure(original_lines)
    modified_elements = parse_smali_structure(modified_lines)
    
    # Determine relative path (for FILE directive)
    rel_path = Path(modified_path).name
    
    patch_lines = []
    patch_lines.append(f"# Generated by smalipatch-generator v{__version__}")
    patch_lines.append(f"# Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    patch_lines.append(f"# Original: {original_path}")
    patch_lines.append(f"# Modified: {modified_path}")
    patch_lines.append("")
    patch_lines.append(f"FILE {rel_path}")
    patch_lines.append("")
    
    # Track processed methods
    processed_methods = set()
    
    # Check for removed methods
    for sig, elem in original_elements.items():
        if elem.type == 'method' and sig not in modified_elements:
            patch_lines.append(f"REMOVE_METHOD {sig}")
            patch_lines.append("")
            processed_methods.add(sig)
    
    # Check for new methods
    for sig, elem in modified_elements.items():
        if elem.type == 'method' and sig not in original_elements:
            patch_lines.append("CREATE_METHOD")
            patch_lines.extend(elem.content)
            patch_lines.append("")
            processed_methods.add(sig)
    
    # Check for modified methods
    for sig, new_elem in modified_elements.items():
        if new_elem.type == 'method' and sig in original_elements and sig not in processed_methods:
            old_elem = original_elements[sig]
            
            if old_elem.content != new_elem.content:
                # Check if entire method should be replaced or patched
                if len(old_elem.content) < 10 or len(new_elem.content) < 10:
                    # Small method - use REPLACE
                    patch_lines.append(f"REPLACE {sig}")
                    patch_lines.extend(new_elem.content[1:-1])  # Exclude .method and .end method
                    patch_lines.append("")
                else:
                    # Large method - try PATCH
                    patch = generate_method_patch(old_elem.content, new_elem.content, sig)
                    if patch:
                        patch_lines.extend(patch)
                        patch_lines.append("")
    
    # Check for field changes
    original_fields = {sig: elem for sig, elem in original_elements.items() if elem.type == 'field'}
    modified_fields = {sig: elem for sig, elem in modified_elements.items() if elem.type == 'field'}
    
    # Removed fields
    for sig in original_fields:
        if sig not in modified_fields:
            # Extract field name for REMOVE_FIELD
            field_name = sig.split()[-1].split(':')[0] if ':' in sig else sig.split()[-1]
            patch_lines.append(f"REMOVE_FIELD {field_name}")
            patch_lines.append("")
    
    # Added fields
    for sig, elem in modified_fields.items():
        if sig not in original_fields:
            patch_lines.append("ADD_FIELD")
            patch_lines.extend(elem.content)
            patch_lines.append("")
    
    patch_lines.append("END")
    patch_lines.append("")
    
    return patch_lines


def interactive_mode(original_file: str, output_file: str):
    """Interactive mode: wait for user to modify file, then generate patch."""
    print("="*60)
    print(f" Smalipatch Generator v{__version__}")
    print("="*60)
    print()
    print(f"Original file: {original_file}")
    print(f"Output patch: {output_file}")
    print()
    print("INSTRUCTIONS:")
    print("1. The script will create a backup of your original file")
    print("2. Modify your smali file with your changes")
    print("3. Save the file")
    print("4. Press ENTER here to generate the patch")
    print()
    
    # Create backup
    backup_path = original_file + ".backup"
    
    try:
        with open(original_file, 'r', encoding='utf-8') as f:
            original_content = f.read()
        
        with open(backup_path, 'w', encoding='utf-8') as f:
            f.write(original_content)
        
        print(f" Backup created: {backup_path}")
        print()
    except IOError as e:
        print(f" Error creating backup: {e}")
        return False
    
    # Wait for user
    input("Press ENTER after you've modified the file and saved it...")
    print()
    
    # Check if file was modified
    try:
        with open(original_file, 'r', encoding='utf-8') as f:
            modified_content = f.read()
    except IOError as e:
        print(f" Error reading modified file: {e}")
        return False
    
    if original_content == modified_content:
        print("âš  Warning: File was not modified. No patch generated.")
        
        # Ask if user wants to delete backup
        response = input("Delete backup file? (y/n): ").strip().lower()
        if response == 'y':
            os.remove(backup_path)
            print(" Backup deleted")
        return False
    
    # Generate patch
    print("Generating patch...")
    
    try:
        patch_lines = generate_patch_from_files(backup_path, original_file)
        
        with open(output_file, 'w', encoding='utf-8', newline='\n') as f:
            f.write('\n'.join(patch_lines))
        
        print()
        print(f" Patch generated successfully: {output_file}")
        print(f"  Lines in patch: {len(patch_lines)}")
        print()
        print("You can now use this patch with:")
        print(f"  smalipatcher.py <work_dir> {output_file}")
        print()
        
        # Ask about backup
        response = input("Keep backup file? (y/n): ").strip().lower()
        if response != 'y':
            os.remove(backup_path)
            print(" Backup deleted")
        else:
            print(f" Backup kept: {backup_path}")
        
        return True
        
    except Exception as e:
        print(f" Error generating patch: {e}")
        return False


def directory_mode(original_dir: str, modified_dir: str, output_file: str):
    """Generate patches for all changed files in directories."""
    print("="*60)
    print(f" Smalipatch Generator v{__version__} - Directory Mode")
    print("="*60)
    print()
    
    orig_path = Path(original_dir)
    mod_path = Path(modified_dir)
    
    if not orig_path.is_dir() or not mod_path.is_dir():
        print(" Error: Both paths must be directories")
        return False
    
    # Find all smali files
    orig_files = {f.relative_to(orig_path): f for f in orig_path.rglob("*.smali")}
    mod_files = {f.relative_to(mod_path): f for f in mod_path.rglob("*.smali")}
    
    all_patches = []
    all_patches.append(f"# Generated by smalipatch-generator v{__version__}")
    all_patches.append(f"# Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    all_patches.append(f"# Original: {original_dir}")
    all_patches.append(f"# Modified: {modified_dir}")
    all_patches.append("")
    
    # Check for removed files
    for rel_path in orig_files:
        if rel_path not in mod_files:
            all_patches.append(f"REMOVE {rel_path.as_posix()}")
            all_patches.append("")
            print(f"  REMOVE: {rel_path}")
    
    # Check for new files
    for rel_path in mod_files:
        if rel_path not in orig_files:
            try:
                with open(mod_files[rel_path], 'r', encoding='utf-8') as f:
                    content = [line.rstrip('\r\n') for line in f.readlines()]
                
                all_patches.append(f"CREATE {rel_path.as_posix()}")
                all_patches.extend(content)
                all_patches.append("")
                print(f"  CREATE: {rel_path}")
            except IOError as e:
                print(f"   Error reading {rel_path}: {e}")
    
    # Check for modified files
    for rel_path in mod_files:
        if rel_path in orig_files:
            orig_file = orig_files[rel_path]
            mod_file = mod_files[rel_path]
            
            try:
                with open(orig_file, 'r', encoding='utf-8') as f:
                    orig_content = f.read()
                with open(mod_file, 'r', encoding='utf-8') as f:
                    mod_content = f.read()
                
                if orig_content != mod_content:
                    print(f"  PATCH:  {rel_path}")
                    patch = generate_patch_from_files(str(orig_file), str(mod_file))
                    # Update FILE path to relative path
                    patch = [line.replace(f"FILE {mod_file.name}", f"FILE {rel_path.as_posix()}") for line in patch if not line.startswith('#')]
                    all_patches.extend(patch)
                    all_patches.append("")
            
            except IOError as e:
                print(f"   Error processing {rel_path}: {e}")
    
    # Write output
    try:
        with open(output_file, 'w', encoding='utf-8', newline='\n') as f:
            f.write('\n'.join(all_patches))
        
        print()
        print(f" Patch generated: {output_file}")
        return True
    except IOError as e:
        print(f" Error writing patch: {e}")
        return False


def main():
    parser = argparse.ArgumentParser(
        description="Generate .smalipatch files from modified smali files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Interactive mode for single file
  %(prog)s MainActivity.smali

  # Specify output file
  %(prog)s MainActivity.smali my-changes.smalipatch

  # Compare entire directories
  %(prog)s --dir original/ modified/ output.smalipatch
        """
    )
    
    parser.add_argument(
        'original',
        help='Original smali file or directory'
    )
    
    parser.add_argument(
        'output',
        nargs='?',
        default='changes.smalipatch',
        help='Output patch file (default: changes.smalipatch)'
    )
    
    parser.add_argument(
        '--dir',
        action='store_true',
        help='Directory comparison mode (compare two directories)'
    )
    
    parser.add_argument(
        '--version',
        action='version',
        version=f'%(prog)s {__version__}'
    )
    
    args = parser.parse_args()
    
    # Validate inputs
    if not Path(args.original).exists():
        print(f" Error: File/directory not found: {args.original}")
        sys.exit(2)
    
    # Directory mode
    if args.dir:
        if not Path(args.output).exists():
            print(f" Error: Modified directory not found: {args.output}")
            sys.exit(2)
        
        # In dir mode: original=orig_dir, output=mod_dir, need 3rd arg
        if len(sys.argv) < 4:
            print(" Error: Directory mode requires 3 arguments:")
            print("  smalipatch-generator.py --dir <original_dir> <modified_dir> <output_patch>")
            sys.exit(2)
        
        modified_dir = args.output
        output_patch = sys.argv[-1] if len(sys.argv) >= 5 else "changes.smalipatch"
        
        success = directory_mode(args.original, modified_dir, output_patch)
        sys.exit(0 if success else 1)
    
    
    else:
        if not Path(args.original).is_file():
            print(f" Error: Not a file: {args.original}")
            sys.exit(2)
        
        success = interactive_mode(args.original, args.output)
        sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
